import csv
import matplotlib.pyplot as plt
import networkx as nx
import re

from config import params_config
from networkx.drawing.nx_agraph import graphviz_layout
from typing import List
from tree.utils import isValidIdentifier


class Node():
    """
    Base class for nodes generated by SQLQuery. Visualization generated by ParseTree. Current
    implementation uses a dict to store label and attributes. Labels are parent nodes and
    attributes are their children

    Node -|- 'SELECT_LIST' (label)
                |- 'id' (attribute)
                |- 'parent' (attribute)

    """

    def __init__(self, label: str, attributes: dict = {}):
        self.label = label
        self.attributes = attributes

    def addAttribute(self, attribute: str, value: str):
        self.attributes[attribute] = value

    def containsAttribute(self, attribute):
        return attribute in self.attributes

    def getLabel(self):
        return self.label

    def getAttributes(self):
        return self.attributes

    def __str__(self):
        return '(' + self.label + ',' + str(self.attributes) + ')'


class SQLQuery():
    """
    Create a SQLQuery class that is the main wrapper for the parser. Query results are also themselves trees. The tree will be of the format:

    SQLQuery -|- SELECT ('PROJECT')
              |- COLUMNS ('SELECT-LIST')
              |- FROM ('JOIN')
              |- TABLES (SQLQuery objects) ('JOIN-LIST')

    See http://www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/5-query-opt/SQL-grammar.html for reference.
    Terminals are leaf nodes of the final parse query tree. (i.e identifiers like column names and provided
    tables). Recursive SQL calls will be implemented in the final tables 'JOIN-LIST' table as calls to
    SQLQuery objects.

    Input:
        tokens                              List[str]

    Output:
        nodes                               List[Node]
        edges                               List[tuple]

    """

    def __init__(self, tokens: List[str], query: str = ''):
        self.query = query
        self.state = 'WAITING'
        self.statement = ''
        self.tokens = tokens
        self.nodes = []
        try:
            # Main logic loop
            for token in tokens:
                if self.statement == '':
                    # The first token has to be an operator
                    if token in params_config:
                        # Update the state
                        self.state = token
                        self.statement = token
                        self.nodes.append(
                            Node(label=token, attributes={}))
                    else:
                        raise SyntaxError
                else:
                    if token in params_config:
                        self.state = token
                        self.nodes.append(
                            Node(token, attributes={}))

                    elif isValidIdentifier(token):
                        identifierList = self.state + '_LIST'
                        lastNode = self.getLastNode()
                        if lastNode.getLabel() == identifierList:
                            lastNode.addAttribute(token, None)
                        else:
                            self.nodes.append(
                                Node(identifierList, attributes={token: None}))
                    elif token == ',':
                        continue
                    elif token == ';':
                        # Termination condition
                        break
                    else:
                        # Token is neither a valid identifier nor SQL operator
                        break
                    self.statement = token
        except SyntaxError:
            print('The first token has to be an operator')

    def getLastNode(self):
        if not self.nodes:
            raise LookupError
        return self.nodes[-1]

    def getNodes(self):
        return self.nodes

    def getQuery(self):
        return self.query


class Tree():
    """
    Base class implementation for viewing layout of tree generated by SQLQuery. Currently uses
    networkx and matplotlib.pyplot for generating tree graph.
    """

    def __init__(self, query: SQLQuery):
        self.query = query
        self.tree = nx.DiGraph()

        query = self.query.getQuery()

        nodes = [query]
        edges = []

        for node in self.query.getNodes():
            # Node should look like (label, attributes)
            # Add node to nodes list
            nodes.append(node.getLabel())

            # Add edge from current node to current parent
            edges.append((query, node.getLabel()))
            for statement, _ in node.getAttributes().items():
                edges.append((node.getLabel(), statement))

        self.tree.add_nodes_from(nodes)
        self.tree.add_edges_from(edges)

    def visualize(self):
        fig, ax = plt.subplots()
        pos = graphviz_layout(self.tree, prog='dot')
        nx.draw(self.tree, pos=pos, with_labels=True, ax=ax)
        plt.show()


class Lexer():
    """
    Lexer tokenizes query into lexemes and categorizes them by token category. The
    output of the lexer is a list of characters that can be used by the SQLQuery
    object which acts as our semantic analyzer for now.
    """

    def __init__(self, pathToRawInput: str):
        self.pathToRawInput = pathToRawInput

    def tokenizeInput(self, getRawOutput: bool = False):
        """
        Tokenize csv file from raw input into list of queries.

        Input:
            self.path_to_raw_input          str
        Output:
            queries                         List[str]
        """
        with open(self.pathToRawInput, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=';')
            # The header of the reader are columns, so skip the first column
            next(reader)
            queries = []
            if getRawOutput:
                for row in reader:
                    queries.extend([query.strip()
                                    for query in row if query != ''])
            else:
                for row in reader:
                    queries.extend([query.strip()
                                    for query in row if query != ''])

            # reset reader
            csvfile.seek(0)
            return queries

    def tokenizeQuery(self, query: str):
        """
        Contains the main logic for parsing queries from tokenizeInput into
        lexemes for use by the semantic analyzer.

        Input:
            query                           str
        Output:
            tokenizedQuery                  list[str]
        """
        tokenizedQuery = []
        for segment in query.split(' '):
            regex = re.split('(,)', segment)
            filteredRegex = filter(lambda s: not(s == ''), regex)
            tokenizedQuery.extend(filteredRegex)
        tokenizedQuery.append(';')
        return tokenizedQuery
